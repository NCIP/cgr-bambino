package Trace;

import java.io.*;
import java.util.*;

public class PhdFile extends Observable implements Runnable {
  // loads base/quality/position data contained in a ".phd" file,
  // as generated by phred.
  
  public Vector data;  //ugh
  public boolean loaded = false;
  public boolean load_error;
  // whether data was loaded successfully
  // FIX ME: use error(), like TraceFile does
  public String filename;
  // name of the trace file, not the actual phdfile
  public boolean reverse_complemented = false;

  public PhdFile () {

  }

  public PhdFile (String name) {
    load(name);
  }

  public PhdFile (String name, Observer o) {
    this.filename = name;
    addObserver(o);
    new Thread(this).start();
  }

  PhdFile copy () {
    // kind of like clone(); manually copies everything
    PhdFile p = new PhdFile();
    p.filename = filename;
    p.data = new Vector();
    p.loaded = loaded;
    for (int i=0; i < data.size(); i++) {
      PhdData pd = (PhdData) data.elementAt(i);
      PhdData nd = new PhdData();
      nd.base = pd.base;
      nd.quality = pd.quality;
      nd.position = pd.position;
      p.data.addElement(nd);
    }
    return(p);
  }

  public void run () {
    load(filename);
    setChanged();
    notifyObservers();
  }

  public void reverse_complement (int num_samples) {
    // reverse-complement the phdfile info.  Requires the count
    // of samples in the trace being rc'd.
    Vector newdata = new Vector();
    PhdData p;
    for (int i = data.size() - 1; i >=0; i--) {
      p = (PhdData) data.elementAt(i);
      p.position = (short) (num_samples - 1 - p.position);
      switch (p.base) {
      case 'a': 	p.base = 't'; p.base_index = 3; break;
      case 'c': 	p.base = 'g'; p.base_index = 2; break;
      case 'g': 	p.base = 'c'; p.base_index = 1; break;
      case 't': 	p.base = 'a'; p.base_index = 0; break;
      case 'A': 	p.base = 'T'; p.base_index = 3; break;
      case 'C': 	p.base = 'G'; p.base_index = 2; break;
      case 'G': 	p.base = 'C'; p.base_index = 1; break;
      case 'T': 	p.base = 'A'; p.base_index = 0; break;
      }
      newdata.addElement(p);
    }
    data = newdata;
    reverse_complemented = ! reverse_complemented;
  }

  void load(String filename) {
    this.filename = filename;
    data = new Vector();
    DataInputStream d;
    try {
      d = StreamDelegator.getStream(filename, 1);
    } catch (IOException e) {
      load_error = true;
      return;
    }
    if (d == null) {
      load_error = true;
      return;
    }
    String line;
    int pos = 0;
    String key, trace_pos;
    char base1, base2;
    boolean broken;
    BufferedReader d2 = new BufferedReader(new InputStreamReader(d));

    try {
      boolean data_mode = false;
      //	while (d.available() > 0) {
      PhdData p;
      while (true) {
	// Infinite (blocking) loop until EOF or parsing is finished.
	// Ugly...
	line = d2.readLine();
	if (line == null) break;
	// EOF (shouldn't happen)
	StringTokenizer st = new StringTokenizer(line);
	if (st.hasMoreTokens()) {
	  key = st.nextToken();
	  if (data_mode) {
	    // the actual data
	    if (key.equals("END_DNA")) break;
	    p = new PhdData();
	    p.base = key.charAt(0);
	    switch (p.base) {
	    case 'a': case 'A' : p.base_index = TraceFile.TRACE_A; break;
	    case 'c': case 'C' : p.base_index = TraceFile.TRACE_C; break;
	    case 'g': case 'G' : p.base_index = TraceFile.TRACE_G; break;
	    case 't': case 'T' : p.base_index = TraceFile.TRACE_T; break;
	    default: p.base_index = TraceFile.TRACE_UNDEF;
	    }

	    p.quality = (short) Integer.parseInt(st.nextToken());
	    p.position = (short) Integer.parseInt(st.nextToken());
	    data.addElement(p);
	    // System.out.println(p.base + " " + p.quality + " " + p.position);
	  } else if (key.equals("BEGIN_DNA")) {
	    data_mode = true;
	  }
	}
      }
      loaded = true;
      load_error = false;
      // System.out.println(data.size());
    } catch (java.io.IOException e) {
      System.out.println(e);
    }
  }
}

